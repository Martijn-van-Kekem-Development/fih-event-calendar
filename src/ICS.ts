import {Match} from "./Objects/Match.js";
import * as fs from "fs/promises";
import {Fetcher} from "./Fetchers/Fetcher.js";

export class ICS {
    /**
     * The stored file paths.
     * @private
     */
    private static filePaths: Record<string, Metadata[]> = {};

    /**
     * Write the ICS string to a file.
     * @param fetcher The fetcher
     * @param ics The ICS content.
     * @param title The ICS title.
     * @param fileName The file name without extension.
     * @param metadata Extra data to save.
     */
    public static async writeToFile(fetcher: Fetcher, ics: string, title: string, fileName: string, metadata: Metadata) {
        const outputFile = `docs/ics/${fileName}.ics`;
        const outputFolder = outputFile.split("/").slice(0, -1).join("/");
        await fs.mkdir(outputFolder, {recursive: true});
        await fs.writeFile(outputFile, ics, {flag: "w+"});

        const fetcherName = fetcher === null ? "total" : fetcher.getName();
        if (typeof this.filePaths[fetcherName] === "undefined") this.filePaths[fetcherName] = [];
        this.filePaths[fetcherName]
            .push({name: title, path: outputFile.split("/").slice(1).join("/"), ...metadata})
    }

    /**
     * Store the file paths in a JSON file.
     */
    public static async storeFilePaths() {
        await fs.writeFile("docs/files.json", JSON.stringify({
            lastUpdate: (new Date()).getTime(),
            paths: this.filePaths
        }));
    }

    /**
     * Convert a calendar to the ICS format.
     * @param title The calendar title.
     * @param id The calendar ID.
     * @param matches The matches to include in this calendar.
     */
    public static calendarToICS(title: string, id: string, matches: Match[]): string {
        const content: string[] = [];

        content.push("BEGIN:VCALENDAR");
        content.push("VERSION:2.0");
        content.push(`PRODID:-//mvk-development//fih-event-calendar//${id}//EN`);
        content.push(`NAME:${title}`);
        content.push(`X-WR-CALNAME:${title}`);
        content.push(`DESCRIPTION:Generated by https://martijn-van-kekem-development.github.io/fih-event-calendar/`);
        content.push(`X-ALT-DESC;FMTTYPE=text/html:<a href="https://martijn-van-kekem-development.github.io/fih-event-calendar/">FIH event calendar</a>`);
        content.push(`X-WR-CALDESC:Generated by https://martijn-van-kekem-development.github.io/fih-event-calendar/`);
        content.push(`REFRESH-INTERVAL;VALUE=DURATION:PT1H`);
        content.push(`X-PUBLISHED-TTL:PT1H`);

        for (let match of matches) {
            content.push(...ICS.matchToICS(match));
        }

        content.push("END:VCALENDAR");

        return this.formatLines(content);
    }

    /**
     * Get the ICS string for a given match.
     * @param match The match object to convert.
     */
    public static matchToICS(match: Match): string[] {
        const content: string[] = [];

        content.push("BEGIN:VEVENT");
        content.push(...Object.entries(match.getICSAttributes()).map(
            ([key, val]) => `${key}:${val}`));
        content.push("END:VEVENT");

        return content;
    }

    /**
     * Parse the content lines to an ICS-safe string.
     * @param content The content lines.
     */
    static formatLines(content: string[]): string {
        let parsed = [...content];

        for (let i = parsed.length - 1; i >= 0; i--) {
            if (parsed[i].length <= 75) continue;
            let line = parsed[i];

            const parts = [line.slice(0, 74)];
            line = line.slice(74);

            // Do for every line that is too long.
            while (line.length >= 75) {
                parts.push(" "  + line.slice(0, 73));
                line = line.slice(73);
            }

            parsed = [...parsed.slice(0, i), ...parts, " " + line, ...parsed.slice(i + 1)];
        }

        return parsed.join("\r\n");
    }
}

export interface Metadata {
    name?: string,
    type?: "total" | "competition",
    index?: number,
    path?: string,
    count?: number

}